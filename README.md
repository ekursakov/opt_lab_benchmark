# opt_lab_benchmark

## Задание
Написать бенчмарк `L2 miss L3 hit -> L2 hit`  

## Описание задачи
В качестве примера выбрана задача умножения матриц.
С ростом размерности матриц они перестают помещаться в кэш и производительность снижается.
Решением этой проблемы является использование блочной схемы умножения матриц.
Но при слишком большом размере блока он может не поместиться в L2 кэш.

В блочном умножении во внутреннем цикле идет ображение к 3м подматрицам размера `block_size * block_size`.
Таким образом, чтобы эффективно использовать L2 кэш, надо подобрать `block_size`, чтобы туда одновременно могли поместиться все 3 блока.

Для демонстрации замедления при постоянных промахах мимо L2 кэша был выставлен размер блока `256 * 256`.

У моего процессора размер L2 кэша 256kb на ядро, поэтому для оптимизации я поставил размер блока `128 * 128`. Вычисления происходят в 32 битных int, поэтому требуемый объем `128 * 128 * 4 * 3 = 196 kb`.

## Результаты и выводы
|Показатель | До | После |
| - | - | -|
| Размер матрицы  | 1536 | 1536 |
| Размер блока  | 256 | 128 |
| L2 Hit Rate  | 0.003 | 0.884 |
| L3 Hit Rate  | 0.996 | 0.995 |
| Время | 5.34 | 4.63 |

Доступ к L2 кэшу по сравнению с L3 быстрее в 2-4 раза.
Уменьшение количества промахов L2 кэша увеличило производительность данной прогаммы в среднем на 16%.

## Оборудование
Intel i5-3350P  
L2 cache: 4 * 256 kb  
L3 cache: 6 mb

Компилятор: Intel C++ Compiler 18.0.30.14
